const mailbox = () => {
  const queue = [];
  let next;
  return {
    async deliver(msg) {
      queue.push(msg);
      if (next) {
        next(queue.shift());
        next = undefined;
      }
    },
    receive() {
      return new Promise(function innerReceive(resolve) {
        const msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

let promise;
const _queueMicrotask = cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {
  throw err;
}, 0));
const INIT = "INIT";
const SUBSCRIBE = "SUBSCRIBE";
const UNSUBSCRIBE = "UNSUBSCRIBE";
const UPDATED = "UPDATED";
const SNAPSHOT = "SNAPSHOT";
const EXIT = "EXIT";
const TERMINATE = "TERMINATE";
const root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window || {
  FCL_REGISTRY: null
};
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
const FCL_REGISTRY = root.FCL_REGISTRY;
let pid = 0b0;
const DEFAULT_TIMEOUT = 5000;
function send(addr, tag, data) {
  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
    expectReply: false
  };
  return new Promise((resolve, reject) => {
    const expectReply = opts.expectReply || false;
    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;
    if (expectReply && timeout) {
      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);
    }
    const payload = {
      to: addr,
      from: opts.from,
      tag,
      data,
      timeout,
      reply: resolve,
      reject
    };
    try {
      if (FCL_REGISTRY[addr]) {
        FCL_REGISTRY[addr].mailbox.deliver(payload);
      }
      if (!expectReply) {
        resolve(true);
      }
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, FCL_REGISTRY[addr], error);
      reject(error);
    }
  });
}
const kill = addr => {
  delete FCL_REGISTRY[addr];
};
const fromHandlers = handlers => async ctx => {
  if (typeof handlers[INIT] === "function") await handlers[INIT](ctx);
  __loop: while (1) {
    const letter = await ctx.receive();
    try {
      if (letter.tag === EXIT) {
        if (typeof handlers[TERMINATE] === "function") {
          await handlers[TERMINATE](ctx, letter, letter.data || {});
        }
        break __loop;
      }
      await handlers[letter.tag]?.(ctx, letter, letter.data || {});
    } catch (error) {
      console.error(`${ctx.self()} Error`, letter, error);
    } finally {
      continue __loop;
    }
  }
};
const parseAddr = addr => {
  if (addr == null) {
    while (FCL_REGISTRY[String(pid)]) {
      pid++;
    }
    return String(pid);
  }
  return String(addr);
};
const spawn = function (fnOrHandlers) {
  let rawAddr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  const addr = parseAddr(rawAddr);
  if (FCL_REGISTRY[addr] != null) return addr;
  FCL_REGISTRY[addr] = {
    addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {},
    error: null
  };
  const ctx = createCtx(addr);
  let fn;
  if (typeof fnOrHandlers === "object") fn = fromHandlers(fnOrHandlers);else fn = fnOrHandlers;
  _queueMicrotask(async () => {
    await fn(ctx);
    kill(addr);
  });
  return addr;
};
const createCtx = addr => ({
  self: () => addr,
  receive: () => FCL_REGISTRY[addr].mailbox.receive(),
  send: function (to, tag, data) {
    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (to == null) return;
    opts.from = addr;
    return send(to, tag, data, opts);
  },
  sendSelf: function (tag, data) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (FCL_REGISTRY[addr]) send(addr, tag, data, opts);
  },
  broadcast: function (tag, data) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    opts.from = addr;
    for (const to of FCL_REGISTRY[addr].subs) send(to, tag, data, opts);
  },
  subscribe: sub => sub != null && FCL_REGISTRY[addr].subs.add(sub),
  unsubscribe: sub => sub != null && FCL_REGISTRY[addr].subs.delete(sub),
  subscriberCount: () => FCL_REGISTRY[addr].subs.size,
  hasSubs: () => !!FCL_REGISTRY[addr].subs.size,
  put: (key, value) => {
    if (key != null) FCL_REGISTRY[addr].kvs[key] = value;
  },
  get: function (key) {
    let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    const value = FCL_REGISTRY[addr].kvs[key];
    return value == null ? fallback : value;
  },
  delete: key => {
    delete FCL_REGISTRY[addr].kvs[key];
  },
  update: (key, fn) => {
    if (key != null) FCL_REGISTRY[addr].kvs[key] = fn(FCL_REGISTRY[addr].kvs[key]);
  },
  keys: () => {
    return Object.keys(FCL_REGISTRY[addr].kvs);
  },
  all: () => {
    return FCL_REGISTRY[addr].kvs;
  },
  where: pattern => {
    return Object.keys(FCL_REGISTRY[addr].kvs).reduce((acc, key) => {
      return pattern.test(key) ? {
        ...acc,
        [key]: FCL_REGISTRY[addr].kvs[key]
      } : acc;
    }, {});
  },
  merge: function () {
    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    Object.keys(data).forEach(key => FCL_REGISTRY[addr].kvs[key] = data[key]);
  },
  fatalError: error => {
    FCL_REGISTRY[addr].error = error;
    for (const to of FCL_REGISTRY[addr].subs) send(to, UPDATED);
  }
});

// Returns an unsubscribe function
// A SUBSCRIBE handler will need to be created to handle the subscription event
//
//  [SUBSCRIBE]: (ctx, letter) => {
//    ctx.subscribe(letter.from)
//    ctx.send(letter.from, UPDATED, ctx.all())
//  }
//
function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  const self = spawn(async ctx => {
    ctx.send(address, SUBSCRIBE);
    while (1) {
      const letter = await ctx.receive();
      const error = FCL_REGISTRY[address].error;
      if (letter.tag === EXIT) {
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      if (error) {
        callback(null, error);
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      callback(letter.data, null);
    }
  });
  return () => send(self, EXIT);
}

// Returns a promise that returns a result
// A SNAPSHOT handler will need to be created to handle the snapshot event
//
//  [SNAPSHOT]: (ctx, letter) => {
//    letter.reply(ctx.all())
//  }
//
function snapshoter(address, spawnFn) {
  spawnFn(address);
  return send(address, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}

export { EXIT, INIT, SNAPSHOT, SUBSCRIBE, TERMINATE, UNSUBSCRIBE, UPDATED, kill, send, snapshoter, spawn, subscriber };
//# sourceMappingURL=actor.module.js.map
